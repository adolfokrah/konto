name: 'Trigger Codemagic Build'
description: 'Triggers a Codemagic build and waits for completion'
inputs:
  codemagic-api-token:
    description: 'Codemagic API token'
    required: true
  codemagic-app-id:
    description: 'Codemagic App ID'
    required: true
  workflow-id:
    description: 'Codemagic workflow ID'
    required: true
  environment:
    description: 'Build environment (staging/production)'
    required: true
    default: 'staging'
  custom-message:
    description: 'Custom message for the build'
    required: false
    default: 'Build triggered'
  branch:
    description: 'Git branch to build'
    required: false
    default: 'main'
  api-base-url:
    description: 'API base URL for the environment'
    required: false
  mnotify-api-key:
    description: 'MNotify API key'
    required: false
  mnotify-sender-id:
    description: 'MNotify sender ID'
    required: false
  mnotify-api-base-url:
    description: 'MNotify API base URL'
    required: false
outputs:
  build-id:
    description: 'Codemagic build ID'
    value: ${{ steps.trigger-build.outputs.build_id }}
  build-url:
    description: 'Codemagic build URL'
    value: ${{ steps.trigger-build.outputs.build_url }}
  build-status:
    description: 'Final build status'
    value: ${{ steps.monitor-build.outputs.build_status }}

runs:
  using: 'composite'
  steps:
    - name: Trigger Codemagic Build
      id: trigger-build
      shell: bash
      run: |
        echo "ðŸš€ Triggering Codemagic build for ${{ inputs.environment }} environment..."
        
        response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -H "x-auth-token: ${{ inputs.codemagic-api-token }}" \
        -d '{
          "appId": "${{ inputs.codemagic-app-id }}",
          "workflowId": "${{ inputs.workflow-id }}",
          "branch": "${{ inputs.branch }}",
          "environment": {
            "variables": {
              "CUSTOM_MESSAGE": "${{ inputs.custom-message }}",
              "BUILD_ENV": "${{ inputs.environment }}",
              "apiBaseUrl": "${{ inputs.api-base-url }}",
              "MNOTIFY_API_KEY": "${{ inputs.mnotify-api-key }}",
              "MNOTIFY_SENDER_ID": "${{ inputs.mnotify-sender-id }}",
              "MNOTIFY_API_BASE_URL": "${{ inputs.mnotify-api-base-url }}"
            }
          }
        }' \
        https://api.codemagic.io/builds)
        
        echo "API Response: $response"
        
        # Extract build ID from response
        build_id=$(echo $response | grep -o '"buildId":"[^"]*"' | cut -d'"' -f4)
        
        if [ -z "$build_id" ]; then
          echo "âŒ Failed to get build ID from response"
          exit 1
        fi
        
        build_url="https://codemagic.io/builds/$build_id"
        
        echo "âœ… Build triggered successfully!"
        echo "ðŸ“± Build ID: $build_id"
        echo "ðŸ”— Build URL: $build_url"
        
        echo "build_id=$build_id" >> $GITHUB_OUTPUT
        echo "build_url=$build_url" >> $GITHUB_OUTPUT

    - name: Monitor Codemagic Build
      id: monitor-build
      shell: bash
      run: |
        build_id="${{ steps.trigger-build.outputs.build_id }}"
        build_url="${{ steps.trigger-build.outputs.build_url }}"
        
        echo "ðŸ”„ Monitoring Codemagic build: $build_id"
        echo "ðŸ“± Build URL: $build_url"
        echo "ðŸ—ï¸ Environment: ${{ inputs.environment }}"
        
        max_wait_time=3600  # 1 hour max wait time
        check_interval=30   # Check every 30 seconds
        elapsed_time=0
        
        while [ $elapsed_time -lt $max_wait_time ]; do
          echo "â±ï¸  Checking build status... (${elapsed_time}s elapsed)"
          
          # Use the builds list endpoint with app ID filter
          status_response=$(curl -s \
            -H "Content-Type: application/json" \
            -H "x-auth-token: ${{ inputs.codemagic-api-token }}" \
            "https://api.codemagic.io/builds?appId=${{ inputs.codemagic-app-id }}&limit=50")
          
          # Extract our specific build status from the builds array
          status=$(echo "$status_response" | grep -A 20 "\"_id\":\"$build_id\"" | grep -m 1 '"status":' | grep -o '"status":"[^"]*"' | cut -d'"' -f4)
          
          echo "ðŸ“Š Current build status: '$status'"
          
          # If we can't find the status, try a different approach
          if [ -z "$status" ]; then
            echo "âš ï¸  Could not find build $build_id in builds list, trying direct approach..."
            # Try to extract just the build IDs to see what's available
            available_builds=$(echo "$status_response" | grep -o '"_id":"[^"]*"' | head -5)
            echo "ðŸ“„ Available builds: $available_builds"
          fi
          
          case $status in
            "finished"|"success"|"successful"|"completed")
              echo "âœ… Build completed successfully!"
              echo "ðŸŽ‰ ${{ inputs.environment }} build finished - marking as PASSED"
              echo "ðŸ“± View build details: $build_url"
              echo "build_status=success" >> $GITHUB_OUTPUT
              exit 0
              ;;
            "failed"|"failure"|"error")
              echo "âŒ Build failed"
              echo "ðŸ”— Check build logs: $build_url"
              echo "build_status=failed" >> $GITHUB_OUTPUT
              exit 1
              ;;
            "canceled"|"cancelled"|"aborted")
              echo "â¹ï¸  Build was canceled"
              echo "ðŸ”— Check build details: $build_url"
              echo "build_status=canceled" >> $GITHUB_OUTPUT
              exit 1
              ;;
            "timeout"|"timed_out")
              echo "â° Build timed out"
              echo "ðŸ”— Check build details: $build_url"
              echo "build_status=timeout" >> $GITHUB_OUTPUT
              exit 1
              ;;
            "building"|"queued"|"preparing"|"testing"|"publishing"|"fetching"|"finishing"|"starting"|"pending")
              echo "ðŸ”„ Build in progress: $status"
              ;;
            "")
              echo "âš ï¸  Could not get build status - will continue monitoring"
              ;;
            *)
              echo "âš ï¸  Unknown status: '$status' - continuing to monitor"
              ;;
          esac
          
          sleep $check_interval
          elapsed_time=$((elapsed_time + check_interval))
        done
        
        echo "âŒ Build monitoring timed out after ${max_wait_time} seconds"
        echo "ðŸ”— Check build status manually: $build_url"
        echo "build_status=timeout" >> $GITHUB_OUTPUT
        exit 1

    - name: Build Success Summary
      if: success()
      shell: bash
      run: |
        build_id="${{ steps.trigger-build.outputs.build_id }}"
        build_url="${{ steps.trigger-build.outputs.build_url }}"
        
        echo "ðŸŽŠ SUCCESS: ${{ inputs.environment }} build completed successfully!"
        echo "ðŸ“± Build ID: $build_id"
        echo "ðŸ”— View artifacts: $build_url"
        echo "âœ… GitHub Action marked as PASSED"
